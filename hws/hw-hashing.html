<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>ICS: Programming HW: Hashing</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="../markdown.css" />
  <script>
  function openTab(evt, tabName) {
    // Declare all variables
    var i, tabcontent, tablinks;

    // Get all elements with class="tabcontent" and hide them
    tabcontent = document.getElementsByClassName("tabcontent");
    for (i = 0; i < tabcontent.length; i++) {
      tabcontent[i].style.display = "none";
    }

    // Get all elements with class="tablinks" and remove the class "active"
    tablinks = document.getElementsByClassName("tablinks");
    for (i = 0; i < tablinks.length; i++) {
      tablinks[i].className = tablinks[i].className.replace(" active", "");
    }

    // Show the current tab, and add an "active" class to the button that opened the tab
    document.getElementById(tabName).style.display = "block";
    evt.currentTarget.className += " active";
  }
  </script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="ics-programming-hw-hashing">ICS: Programming HW: Hashing</h1>
<p><a href="index.html">Go up to the ICS HW page</a> (<a href="index.md">md</a>) | <a href="hw-hashing-tabbed.html">view tabbed version</a></p>
<h3 id="overview">Overview</h3>
<p>In this assignment, you will be examining some of the issues surrounding hashes and their security applications.</p>
<p>There are two separate tasks for this assignment, as described below.</p>
<p>You should be familiar with the <a href="../slides/encryption.html#/hashing">hashing section of the encryption slides</a>.</p>
<h3 id="changelog">Changelog</h3>
<p>Any changes to this page will be put here for easy reference. Typo fixes and minor clarifications are not listed here. So far there aren’t any significant changes to report.</p>
<h3 id="task-1-crc-insecurity">Task 1: CRC insecurity</h3>
<p>Your job is to write a C or C++ program (necessary for speed reasons) that, when given an input file and a CRC checksum, will modify that message, and ensure that the modified version matches the CRC checksum. You can use either C or C++ for this part, it doesn’t matter.</p>
<p><a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC32</a> is used extensively in network transmission – that podcast that you downloaded used thousands of CRC32 checksums to transfer it over the network. We are going to use CRC16 – it’s a bit quicker to brute-force a hash, but has the same principles as CRC32.</p>
<h4 id="set-up">Set-up</h4>
<p>For this task, you will need a few functions from the <a href="https://www.boost.org/">Boost C++ library</a>, as they will perform the CRC hash computation. Your program should include the library as follows:</p>
<pre><code>#include &lt;boost/crc.hpp&gt;</code></pre>
<p>To compile it, you first have to get Boost on your computer. One option is to install it through your operating system’s package manager – and older version of Boost is fine, as the CRC code has not changed much in the last 6 years. You can also download the Boost library, and uncompress it on your computer. You can find the latest version (1.81.0) <a href="https://www.boost.org/users/history/version_1_81_0.html">here</a>; the .zip file direct download link is <a href="https://boostorg.jfrog.io/artifactory/main/release/1.81.0/source/boost_1_81_0.zip">here</a>. You would then want to unzip that file.</p>
<p>Once on your computer, your compilation line will be:</p>
<pre><code>clang++ -O2 -I boost_1_81_0/ -o crc16 crc16.cpp</code></pre>
<p>The <code>-I boost_1_81_0/</code> parameter tells the compiler to look in that directory, as it needs that to find the <code>boost/crc.hpp</code> file from the include line, above. Change it as appropriate for wherever you unzipped Boost to. If you installed it through your OS’es package manager, you would not include that flag.</p>
<p><strong>IMPORTANT NOTE:</strong> When you submit your code to Gradescope, you must <strong><em>NOT</em></strong> have the <code>-I boost_1_81_0/</code> flag present, as Boost will be installed on that autograder image.</p>
<h4 id="resources">Resources</h4>
<ul>
<li>Boost libraries:
<ul>
<li><a href="https://en.wikipedia.org/wiki/Boost_(C++_libraries)">Wikipedia overview</a></li>
<li><a href="https://www.boost.org/doc/libs/1_81_0/libs/crc/crc.html">Documentation</a></li>
<li><a href="https://stackoverflow.com/questions/2573726/how-to-use-boostcrc">Example usage of CRC functions</a></li>
</ul></li>
<li><a href="https://www.lammertbies.nl/comm/info/crc-calculation.html">Online CRC16 calculator</a> (does not include trailing newlines)</li>
</ul>
<h4 id="assignment">Assignment</h4>
<p>Your program should be called <code>crc16.cpp</code>, even if it’s a C program; you will provide a Makefile to compile it (described below). It will be run with two command-line parameters:</p>
<ol type="1">
<li>the input file name to read from</li>
<li>the desired CRC value (in hex) - this will be 4 hexadecimal characters, such as ‘abcd’ (we will leave out the leading ‘0x’)</li>
</ol>
<p>A sample execution:</p>
<pre><code>$ clang++ -O2 -o crc16 crc16.cpp 
$ cat input.txt 
Things are going just great!
$ ./crc16 input.txt abcd
$ cat output.txt ; /bin/echo
Things are going just great!

If you think things can&#39;t get worse it&#39;s probably only because you lack sufficient imagination.

   &amp;No
$ </code></pre>
<p>The program should write its output to a file named <code>output.txt</code>. Note that the output.txt file above does not have a trailing newline character. That file should contain the following:</p>
<ol type="1">
<li>The contents of the original file in its entirety (it will consist only of printable ASCII characters, as well as newlines)</li>
<li>A message of your own, which demonstrates that you <em>could</em> modify the original message, possibly maliciously, if desired. (Do not actually modify the original message – just add your message after the original.)</li>
<li>A reasonable amount of PRINTABLE ASCII characters (decimal values 32 - 127) to the end of the input file (reasonable means 10 or fewer), such that the new output file has the same CRC as the desired CRC value (the second command-line parameter). The only purpose of these characters is to affect the CRC value.</li>
</ol>
<h4 id="important-notes">Important Notes</h4>
<ul>
<li><strong>CRC16:</strong> We will be using the CRC16 algorithm, NOT the CRC32 algorithm, to allow the program to run in a reasonably short time frame. Boost can do both, so be careful.</li>
<li><strong>Testing:</strong> As mentioned above, there is an <a href="https://www.lammertbies.nl/comm/info/crc-calculation.html">online CRC16 calculator</a> to help you ensure that you are generating your CRC-16 hashes correctly. For testing your CRC16 hashes, you should NOT use a string that has a newline, as that web page can not handle those.</li>
<li><strong>Newlines:</strong> There are two things to be watch out for with newlines:
<ol type="1">
<li>There are differences between Linux and Windows platforms (see <a href="http://en.wikipedia.org/wiki/Newline">Wikipedia</a> for details). Your program will be run (and graded) in a Linux environment.</li>
<li>Trailing newlines (<code>\n</code>) affect the CRC16 value of a file, but are often overlooked. Be careful not to unintentionally add any extra newlines that would change the CRC value of <code>output.txt</code>. For example, the CRC16 for “hello world” with no trailing newline is 0x39c1 on a UNIX system, but with a trailing newline it is 0x9778.</li>
</ol></li>
</ul>
<h4 id="additional-hints">Additional Hints</h4>
<ul>
<li>You need to create a new <code>crc_16_type</code> result EACH time you compute the CRC value; you can’t re-use it very easily.</li>
<li>Your program will be given 60 seconds to run when we grade it. This should be enough time for CRC16, but you may want to include the <code>-O2</code> compilation flag.</li>
</ul>
<h3 id="task-2-dictionary-attacks">Task 2: Dictionary Attacks</h3>
<p>Modern computer systems do not store the password in plain text, but instead store a hash of that password. When a user logs in, a hash is taken of the password the user enters, and that hash is compared to the saved one – if they match, then the login is successful. Since hashes are one-way functions, we cannot determine a password based solely on the hash. Instead, we perform a <a href="https://en.wikipedia.org/wiki/Dictionary_attack">dictionary attack</a>: we take every word in the dictionary, hash each one, and then compare the hashes. If we had more computing power, we could compute <em>all</em> passwords of 8 printable characters, and hash each one of those.</p>
<p>If all that was stored was the hash of the password, then it would be easy to figure out one from the other. For example, an Internet search for the hash 5f0974ee455c4cd57c58dfb04f3d070b1f365d0ed4401dbf28089b308b019a67 yields <a href="https://hashdecryption.com/h/plain/tableau">this site</a>, which tells us that the password is ‘tableau’.</p>
<p>To prevent a leaked password hash from being easily looked up online, sites will add a <em>salt</em>, which is a suffix added to each password. If the salt is <code>_abcdefg</code>, then the password <code>tableau</code> would have the string <code>tableau_abcdefg</code> hashed (salting is just string concatenation), and the hash of that is stored in the password file. That hash of <code>tableau_abcdefg</code> is 4b9b0b7c0b94c98828d6eac32e0bf081dba5c686e2cae111bdfd5c042ac53e8f, and searching for that does not yield any results. In practice, salts are long strings – 50 characters is more typical. We’ll use much smaller salts in this assignment.</p>
<p>For this part, we are only using SHA-256 hashes. This part may be written in any programming language.</p>
<h4 id="set-up-1">Set-up</h4>
<p>A password file will be provided in the following format:</p>
<pre><code>aaron 36a095da4e23a3b35db038092aef1b8c3dbd4eb7068d3fdc869af10849476f82
alex 553c165c0199e45e6c44ea743650d7f48a62c82357d46a03179b86719d670b2a
chase 83352f28d732fa2a255d6c69d5c332f6b9f421d89bacb2ed334b0841bfce6661
natasha f9c6b88c040ec9388f78d50a06d2da92362f9d9a219a3180fde59c768da3f366
sam 1d06b71965f3c7466467c7a89dd1aadfffe9da9f409017c1fa363b49312d70f4
taher 226f7f2a65158d441748b1ce9543b5027af1a7438314371d3dfccf12fba85edf</code></pre>
<p>The file is ASCII, and all usernames will be alphanumeric strings. There is exactly one space between the two tokens on any given line. The hashes shown are SHA-256 hashes. The passwords used to generate those hashes are shown in the execution run, below.</p>
<p>The dictionary file we will use is located at /usr/share/dict/words on most Linux systems (assuming that the <code>wamerican</code> package has been installed); you can find a copy in Canvas’ Files. It contains about 100,000 words. The file has one word per line, with no whitespace. We have a version stored on Canvas’ Files, and you should use that (the one in /usr/share/dict/words is UTF-8, and we want it to be ASCII; the one on Canvas’ Files was converted to ASCII for this assignment).</p>
<p>You are welcome to create your own versions of these files – meaning you can create a file with only 100 (or so) words to use for testing. If you want to find the SHA-256 password for a string, try running: <code>echo -n banana | sha256sum</code> in Linux or Mac OS X. Note that the <code>-n</code> part is important in that echo statement – it ensures that there is no return (<code>\n</code>) put at the end of the string that you are taking the SHA-256 hash of. You can also use any online SHA-256 generator (the hash of <code>banana</code>, by the way, is b493d48364afe44d11c0165cf470a4164d1e2609911ef998be868d46ade3de4e).</p>
<h4 id="assignment-1">Assignment</h4>
<p>Your program should find any and all passwords matches in the password file by hashing each of the words in the dictionary file. Your program will be provided with three command-line parameters: the dictionary file, the password file, and the salt, in that order. For this assignment, the salt will always be an alphanumeric string, and underscores are also allowed.</p>
<p>You may write this in any programming language (although you have to let us know two days ahead of time if you want to use a language that the autograder is not already configured for). You are expected to use the SHA-256 routines in your language. Because we do not know the language you are using, you will have to provide a Makefile and a <code>dictionary.sh</code> shell script to compile and run the program.</p>
<p>Your program should print out one line for the passwords that it finds. Here is a sample execution run for the password file shown above:</p>
<pre><code>$ ./dictionary.sh words passwords.txt _l337_h4x0r
password for chase is: astound
password for sam is: flotation
password for alex is: patois
password for aaron is: plastic
password for taher is: reunification
password for natasha is: spade
$ 
</code></pre>
<p>The order you print it out does not matter (we are going to sort your output), but the exact text on each line does, as we are going to have it graded by an autograder. Not all the passwords may be found in the words file. We will not give you invalid input (meaning files that do not exist, a wrong number of command-line parameters, etc.). Both the words file and the password file will be ASCII files with at least 1 line in each file. The salt will only be alphanumeric characters and underscores.</p>
<p>If no passwords are found, then the program should produce no output.</p>
<p>While we do not really care about efficiency, your program must run in a reasonable time. Basically it – along with the program in the previous task – should not time out in Gradescope.</p>
<h3 id="other-files">Other Files</h3>
<h4 id="makefile">Makefile</h4>
<p>You will need to submit a <code>Makefile</code>. It will have to compile your CRC-16 code, and (possibly) your dictionary attack code.</p>
<p>If you are using a language for the dictionary attack code that does not need compilation, such as Python, your Makefile will look like the following:</p>
<pre><code>main:
    clang++ -O2 -o crc16 crc16.cpp</code></pre>
<p>Note that the indentation is a tab, not spaces! Make is annoying that way. Also note that we did not use the <code>-I boost_1_81_0/</code> flag.</p>
<p>If you are using a language for your dictionary attack code that <em>does</em> need compilation, such as Java, your Makefile will look like the following:</p>
<pre><code>main:
    clang++ -O2 -o crc16 crc16.cpp
    javac Dictionary.java</code></pre>
<p>Change the name of your source code file as appropriate. Also note that we did not use the <code>-I boost_1_81_0/</code> flag.</p>
<h4 id="shell-script">Shell script</h4>
<p>The CRC code does not need a shell script, since it will be compiled into a <code>crc16</code> binary by the Makefile above. Your dictionary attack will need a shell script, which will likely be one of the following:</p>
<pre><code>#!/bin/bash
python3 dictionary.py $@</code></pre>
<pre><code>#!/bin/bash
java Dictionary $@</code></pre>
<p>Change the name of your file and/or class as appropriate for your code.</p>
<h3 id="submission">Submission</h3>
<p>There are four files to submit:</p>
<ul>
<li><code>crc16.cpp</code> from task 1</li>
<li><code>Makefile</code>, <code>dictionary.sh</code> and your source code from task 2</li>
</ul>
<p>We will be compiling your submission with <code>make</code>.</p>
</body>
</html>
